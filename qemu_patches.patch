From 61928f76276683059342cd077ef02749e7524776 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Wed, 11 May 2022 07:53:06 -0700
Subject: [PATCH 1/8] Synced with 742848ad987b27fdbeab11323271ca7d196152fb

---
 include/tcg/tcg.h         |  10 +++
 linux-user/main.c         |  46 ++++++++++++
 tcg/i386/tcg-target.c.inc | 145 ++++++++++++++++++++++++++++++++++++++
 tcg/tcg.c                 |  34 +++++++++
 4 files changed, 235 insertions(+)

diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 26a70526f1..063c4c18d1 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -35,6 +35,16 @@
 #include "tcg-target.h"
 #include "tcg/tcg-cond.h"
 
+#ifdef CONFIG_LINUX_USER
+#define CANNOLI
+#ifdef CANNOLI
+#include "/home/pleb/cannoli/qemu_library/ffi/cannoli.h"
+
+// Defined in `linux-user/main.c`
+extern Cannoli *cannoli;
+#endif // CANNOLI
+#endif // CONFIG_LINUX_USER
+
 /* XXX: make safe guess about sizes */
 #define MAX_OP_PER_INSTR 266
 
diff --git a/linux-user/main.c b/linux-user/main.c
index 7ca48664e4..481f33e121 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -54,6 +54,10 @@
 #include "loader.h"
 #include "user-mmap.h"
 
+#ifdef CANNOLI
+#include <dlfcn.h>
+#endif
+
 #ifndef AT_FLAGS_PRESERVE_ARGV0
 #define AT_FLAGS_PRESERVE_ARGV0_BIT 0
 #define AT_FLAGS_PRESERVE_ARGV0 (1 << AT_FLAGS_PRESERVE_ARGV0_BIT)
@@ -86,6 +90,13 @@ static bool enable_strace;
 static int last_log_mask;
 static const char *last_log_filename;
 
+#ifdef CANNOLI
+/*
+ * Pointer to bindings registed by `query_version` in Cannoli
+ */
+Cannoli *cannoli;
+#endif
+
 /*
  * When running 32-on-64 we should make sure we can fit all of the possible
  * guest address space into a contiguous chunk of virtual host memory.
@@ -260,6 +271,37 @@ static void handle_arg_log_filename(const char *arg)
     last_log_filename = arg;
 }
 
+#ifdef CANNOLI
+static void handle_arg_cannoli(const char *arg)
+{
+    // Initialize the Cannoli library
+    void *cannoli_lib = dlopen(arg, RTLD_NOW);
+    if(!cannoli_lib) {
+        fprintf(stderr, "Cannoli: Failed to load library \"%s\"\n", dlerror());
+        exit(EXIT_FAILURE);
+    }
+
+    // Get the entry point for Cannoli
+    Cannoli* (*query_version)(void) = dlsym(cannoli_lib, CANNOLI_ENTRY);
+    if(!query_version) {
+        fprintf(stderr, "Cannoli: Failed to get entry point \"%s\"\n",
+            dlerror());
+        exit(EXIT_FAILURE);
+    }
+
+    // Query binding information
+    cannoli = query_version();
+
+    // Check version
+    if(cannoli->version != CANNOLI_VERSION) {
+        fprintf(stderr, "Cannoli: Version mismatch, expected %" PRIx64
+            ", got %" PRIx64 "\n",
+            CANNOLI_VERSION, cannoli->version);
+        exit(EXIT_FAILURE);
+    }
+}
+#endif
+
 static void handle_arg_set_env(const char *arg)
 {
     char *r, *p, *token;
@@ -463,6 +505,10 @@ static const struct qemu_argument arg_table[] = {
      "range[,...]","filter logging based on address range"},
     {"D",          "QEMU_LOG_FILENAME", true, handle_arg_log_filename,
      "logfile",     "write logs to 'logfile' (default stderr)"},
+#ifdef CANNOLI
+    {"cannoli",    "QEMU_CANNOLI" ,    true,  handle_arg_cannoli,
+     "cannoli.so", "Falk's Cannoli fast JIT hooks"},
+#endif
     {"p",          "QEMU_PAGESIZE",    true,  handle_arg_pagesize,
      "pagesize",   "set the host page size to 'pagesize'"},
     {"singlestep", "QEMU_SINGLESTEP",  false, handle_arg_singlestep,
diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index b5c6159853..0e7d88c67e 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -45,9 +45,11 @@ static const int tcg_target_reg_alloc_order[] = {
 #if TCG_TARGET_REG_BITS == 64
     TCG_REG_RBP,
     TCG_REG_RBX,
+#ifndef CANNOLI
     TCG_REG_R12,
     TCG_REG_R13,
     TCG_REG_R14,
+#endif
     TCG_REG_R15,
     TCG_REG_R10,
     TCG_REG_R11,
@@ -2245,9 +2247,36 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
         tcg_out_test_alignment(s, true, addrlo, addrhi, a_bits);
     }
 
+#ifdef CANNOLI
+    tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
+#endif // CANNOLI
+
     tcg_out_qemu_ld_direct(s, datalo, datahi, addrlo, x86_guest_base_index,
                            x86_guest_base_offset, x86_guest_base_seg,
                            is64, opc);
+
+#ifdef CANNOLI
+    if(cannoli && cannoli->lift_memop) {
+        // Should be large enough for any reasonable shellcode
+        uint8_t shellcode[1024];
+
+        // Invoke lifting callback
+        size_t shellcode_size = cannoli->lift_memop(
+            0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
+            sizeof(shellcode));
+
+        // Make sure the SO library author is not being naughty ;)
+        if(shellcode_size > sizeof(shellcode)) {
+            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            exit(EXIT_FAILURE);
+        }
+
+        // Inject the shellcode into the JIT stream
+        for(size_t ii = 0; ii < shellcode_size; ii++) {
+            tcg_out8(s, shellcode[ii]);
+        }
+    }
+#endif // CANNOLI
 #endif
 }
 
@@ -2336,6 +2365,28 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
     add_qemu_ldst_label(s, false, is64, oi, datalo, datahi, addrlo, addrhi,
                         s->code_ptr, label_ptr);
 #else
+#ifdef CANNOLI
+    if(cannoli && cannoli->lift_memop) {
+        // Should be large enough for any reasonable shellcode
+        uint8_t shellcode[1024];
+
+        // Invoke lifting callback
+        size_t shellcode_size = cannoli->lift_memop(
+            1, datalo, addrlo, opc & MO_SIZE, shellcode, sizeof(shellcode));
+
+        // Make sure the SO library author is not being naughty ;)
+        if(shellcode_size > sizeof(shellcode)) {
+            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            exit(EXIT_FAILURE);
+        }
+
+        // Inject the shellcode into the JIT stream
+        for(size_t ii = 0; ii < shellcode_size; ii++) {
+            tcg_out8(s, shellcode[ii]);
+        }
+    }
+#endif // CANNOLI
+
     a_bits = get_alignment_bits(opc);
     if (a_bits) {
         tcg_out_test_alignment(s, false, addrlo, addrhi, a_bits);
@@ -4021,6 +4072,57 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_push(s, tcg_target_callee_save_regs[i]);
     }
 
+#ifdef CANNOLI
+    if(cannoli && cannoli->jit_entry) {
+        // Save all of the registers which are caller-saved. In theory we could
+        // be a bit more specific here, but this allows us to not interfere
+        // with any shenanigans that QEMU might do now, or in the future. This
+        // gives us our own environment to run in where we don't have to worry
+        // about specifics
+        //
+        // x86-64 SYS-V ABI:
+        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        tcg_out_push(s, TCG_REG_RAX);
+        tcg_out_push(s, TCG_REG_RDI);
+        tcg_out_push(s, TCG_REG_RSI);
+        tcg_out_push(s, TCG_REG_RDX);
+        tcg_out_push(s, TCG_REG_RCX);
+        tcg_out_push(s, TCG_REG_R8);
+        tcg_out_push(s, TCG_REG_R9);
+        tcg_out_push(s, TCG_REG_R10);
+        tcg_out_push(s, TCG_REG_R11);
+
+        // Make some room on the stack for the 3 64-bit return values, but also
+        // align the stack to a 16-byte boundary so it matches the x64 ABI
+        tcg_out_addi(s, TCG_REG_RSP, -32);
+
+        // Load a pointer to the temporary storage for the (u64, u64) into the
+        // first argument to `jit_entry`
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_RSP);
+
+        tcg_out_call(s, (void*)cannoli->jit_entry);
+
+        // Load the temporary values returned from `jit_entry`. These are the
+        // values for our registers we have full control over in the JIT
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_REG_RSP, 0x00);
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_REG_RSP, 0x08);
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_REG_RSP, 0x10);
+
+        // Restore the stack
+        tcg_out_addi(s, TCG_REG_RSP, 32);
+        tcg_out_pop(s, TCG_REG_R11);
+        tcg_out_pop(s, TCG_REG_R10);
+        tcg_out_pop(s, TCG_REG_R9);
+        tcg_out_pop(s, TCG_REG_R8);
+        tcg_out_pop(s, TCG_REG_RCX);
+        tcg_out_pop(s, TCG_REG_RDX);
+        tcg_out_pop(s, TCG_REG_RSI);
+        tcg_out_pop(s, TCG_REG_RDI);
+        tcg_out_pop(s, TCG_REG_RAX);
+    }
+#endif
+
 #if TCG_TARGET_REG_BITS == 32
     tcg_out_ld(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP,
                (ARRAY_SIZE(tcg_target_callee_save_regs) + 1) * 4);
@@ -4066,6 +4168,49 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     if (have_avx2) {
         tcg_out_vex_opc(s, OPC_VZEROUPPER, 0, 0, 0, 0);
     }
+
+#ifdef CANNOLI
+    if(cannoli && cannoli->jit_exit) {
+        // Save all of the registers which are caller-saved. In theory we could
+        // be a bit more specific here, but this allows us to not interfere
+        // with any shenanigans that QEMU might do now, or in the future. This
+        // gives us our own environment to run in where we don't have to worry
+        // about specifics
+        //
+        // x86-64 SYS-V ABI:
+        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        tcg_out_push(s, TCG_REG_RAX);
+        tcg_out_push(s, TCG_REG_RDI);
+        tcg_out_push(s, TCG_REG_RSI);
+        tcg_out_push(s, TCG_REG_RDX);
+        tcg_out_push(s, TCG_REG_RCX);
+        tcg_out_push(s, TCG_REG_R8);
+        tcg_out_push(s, TCG_REG_R9);
+        tcg_out_push(s, TCG_REG_R10);
+        tcg_out_push(s, TCG_REG_R11);
+
+        // Load the 3 controlled registers into the first 3 arguments of the
+        // JIT exit function
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_R12);
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RSI, TCG_REG_R13);
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDX, TCG_REG_R14);
+
+        tcg_out_call(s, (void*)cannoli->jit_exit);
+
+        // Restore the stack
+        tcg_out_pop(s, TCG_REG_R11);
+        tcg_out_pop(s, TCG_REG_R10);
+        tcg_out_pop(s, TCG_REG_R9);
+        tcg_out_pop(s, TCG_REG_R8);
+        tcg_out_pop(s, TCG_REG_RCX);
+        tcg_out_pop(s, TCG_REG_RDX);
+        tcg_out_pop(s, TCG_REG_RSI);
+        tcg_out_pop(s, TCG_REG_RDI);
+        tcg_out_pop(s, TCG_REG_RAX);
+    }
+#endif
+
     for (i = ARRAY_SIZE(tcg_target_callee_save_regs) - 1; i >= 0; i--) {
         tcg_out_pop(s, tcg_target_callee_save_regs[i]);
     }
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 0f9cfe96f2..739a4641c3 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4350,6 +4350,40 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
 #endif
                 s->gen_insn_data[num_insns][i] = a;
             }
+
+#ifdef CANNOLI
+            // First `insn_start` variable is the PC of the instruction.
+            // It may be encoded as 2 32-bit ints when emulating a
+            // larger-than-native architecture than the host of QEMU.
+            //
+            // We let the code above us handle that decoding, thus we just
+            // access the `gen_insn_data` ourselves
+            if(cannoli) {
+                if(cannoli->lift_instruction) {
+                    // Should be large enough for any reasonable shellcode
+                    uint8_t shellcode[1024];
+
+                    // Get the PC
+                    target_ulong pc = s->gen_insn_data[num_insns][0];
+
+                    // Invoke lifting callback
+                    size_t shellcode_size =
+                        cannoli->lift_instruction(
+                            pc, shellcode, sizeof(shellcode));
+
+                    // Make sure the SO library author is not being naughty ;)
+                    if(shellcode_size > sizeof(shellcode)) {
+                        fprintf(stderr, "Cannoli: Shellcode too large\n");
+                        exit(EXIT_FAILURE);
+                    }
+
+                    // Inject the shellcode into the JIT stream
+                    for(size_t ii = 0; ii < shellcode_size; ii++) {
+                        tcg_out8(s, shellcode[ii]);
+                    }
+                }
+            }
+#endif
             break;
         case INDEX_op_discard:
             temp_dead(s, arg_temp(op->args[0]));
-- 
2.35.1


From b23f51273e9411d7a0d7808ec88ded311e05cfc7 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Thu, 12 May 2022 19:18:52 -0700
Subject: [PATCH 2/8] Style cleanup, more comments

---
 include/tcg/tcg.h         |  14 ++-
 linux-user/main.c         |  24 +++--
 tcg/i386/tcg-target.c.inc | 222 +++++++++++++++++++++++++++-----------
 tcg/tcg.c                 |  57 +++++-----
 4 files changed, 217 insertions(+), 100 deletions(-)

diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 063c4c18d1..20dc3c68a1 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -35,15 +35,23 @@
 #include "tcg-target.h"
 #include "tcg/tcg-cond.h"
 
+/*
+ * Currently we only support Cannoli in qemu-user mode. In theory it would work
+ * in qemu-system, but it's kinda pointless if you don't have hooks/traces for
+ * context switches, page table changes, etc.
+ */
 #ifdef CONFIG_LINUX_USER
 #define CANNOLI
 #ifdef CANNOLI
 #include "/home/pleb/cannoli/qemu_library/ffi/cannoli.h"
 
-// Defined in `linux-user/main.c`
+/*
+ * Defined in `linux-user/main.c`. Holds global cannoli state and callback
+ * pointers into Rust
+ */
 extern Cannoli *cannoli;
-#endif // CANNOLI
-#endif // CONFIG_LINUX_USER
+#endif /* CANNOLI */
+#endif /* CONFIG_LINUX_USER */
 
 /* XXX: make safe guess about sizes */
 #define MAX_OP_PER_INSTR 266
diff --git a/linux-user/main.c b/linux-user/main.c
index 481f33e121..86238c2441 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -55,8 +55,11 @@
 #include "user-mmap.h"
 
 #ifdef CANNOLI
+/*
+ * Cannoli is dynamically loaded, thus, we gotta pull in dynamic headers!
+ */
 #include <dlfcn.h>
-#endif
+#endif /* CANNOLI */
 
 #ifndef AT_FLAGS_PRESERVE_ARGV0
 #define AT_FLAGS_PRESERVE_ARGV0_BIT 0
@@ -92,10 +95,10 @@ static const char *last_log_filename;
 
 #ifdef CANNOLI
 /*
- * Pointer to bindings registed by `query_version` in Cannoli
+ * Pointer to bindings registered by `query_version` in Cannoli
  */
 Cannoli *cannoli;
-#endif
+#endif /* CANNOLI */
 
 /*
  * When running 32-on-64 we should make sure we can fit all of the possible
@@ -272,16 +275,21 @@ static void handle_arg_log_filename(const char *arg)
 }
 
 #ifdef CANNOLI
+/*
+ * Handles the `--cannoli` command line argument, or the `QEMU_CANNOLI`
+ * environment variable. This is where we load up Cannoli. This can only be
+ * called once.
+ */
 static void handle_arg_cannoli(const char *arg)
 {
-    // Initialize the Cannoli library
+    /* Initialize the Cannoli library */
     void *cannoli_lib = dlopen(arg, RTLD_NOW);
     if(!cannoli_lib) {
         fprintf(stderr, "Cannoli: Failed to load library \"%s\"\n", dlerror());
         exit(EXIT_FAILURE);
     }
 
-    // Get the entry point for Cannoli
+    /* Get the entry point for Cannoli */
     Cannoli* (*query_version)(void) = dlsym(cannoli_lib, CANNOLI_ENTRY);
     if(!query_version) {
         fprintf(stderr, "Cannoli: Failed to get entry point \"%s\"\n",
@@ -289,10 +297,10 @@ static void handle_arg_cannoli(const char *arg)
         exit(EXIT_FAILURE);
     }
 
-    // Query binding information
+    /* Query binding information */
     cannoli = query_version();
 
-    // Check version
+    /* Check version */
     if(cannoli->version != CANNOLI_VERSION) {
         fprintf(stderr, "Cannoli: Version mismatch, expected %" PRIx64
             ", got %" PRIx64 "\n",
@@ -300,7 +308,7 @@ static void handle_arg_cannoli(const char *arg)
         exit(EXIT_FAILURE);
     }
 }
-#endif
+#endif /* CANNOLI */
 
 static void handle_arg_set_env(const char *arg)
 {
diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index 0e7d88c67e..99168526d6 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -46,10 +46,14 @@ static const int tcg_target_reg_alloc_order[] = {
     TCG_REG_RBP,
     TCG_REG_RBX,
 #ifndef CANNOLI
+/*
+ * Prevent the register scheduler from using r12, r13, and r14. This allows us
+ * to have exclusive access to them through the entire JIT execution
+ */
     TCG_REG_R12,
     TCG_REG_R13,
     TCG_REG_R14,
-#endif
+#endif /* CANNOLI */
     TCG_REG_R15,
     TCG_REG_R10,
     TCG_REG_R11,
@@ -2229,6 +2233,30 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
     oi = *args++;
     opc = get_memop(oi);
 
+#ifdef CANNOLI
+    /*
+     * This is our load hook. We're first saving off the address.
+     *
+     * Save the address into `r14`. The address often is the output of the load
+     * and thus the address gets clobbered by the load itself. Only saved if
+     * Cannoli has registered memory hooks.
+     */
+    if(cannoli && cannoli->lift_memop) {
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         */
+        if((TCG_TARGET_REG_BITS == 32 && is64) ||
+                (TARGET_LONG_BITS > TCG_TARGET_REG_BITS)) {
+            fprintf(stderr,
+                "Cannoli: 64-bit load on 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
+    }
+#endif /* CANNOLI */
+
 #if defined(CONFIG_SOFTMMU)
     mem_index = get_mmuidx(oi);
 
@@ -2247,37 +2275,57 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
         tcg_out_test_alignment(s, true, addrlo, addrhi, a_bits);
     }
 
-#ifdef CANNOLI
-    tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
-#endif // CANNOLI
-
     tcg_out_qemu_ld_direct(s, datalo, datahi, addrlo, x86_guest_base_index,
                            x86_guest_base_offset, x86_guest_base_seg,
                            is64, opc);
+#endif
 
 #ifdef CANNOLI
+    /*
+     * In the second stage of our load hooks, the load has completed. This
+     * means we now have access to the contents of the load. Request the Rust
+     * code to provide us with some shellcode to inject directly into the
+     * stream. We will provide Rust with the register indicies which contain
+     * the address and data values
+     */
     if(cannoli && cannoli->lift_memop) {
-        // Should be large enough for any reasonable shellcode
+        /* Should be large enough for any reasonable shellcode */
         uint8_t shellcode[1024];
 
-        // Invoke lifting callback
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         * (yes, this code _is_ duplicated above, but it should compile to no
+         * cost, so we'll use it excessively to make the code less likely to
+         * break or be accidentally removed)
+         */
+        if((TCG_TARGET_REG_BITS == 32 && is64) ||
+                (TARGET_LONG_BITS > TCG_TARGET_REG_BITS)) {
+            fprintf(stderr,
+                "Cannoli: 64-bit load on 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        /*
+         * Invoke lifting callback. Note that we use r14 as the address, as
+         * we saved it there above.
+         */
         size_t shellcode_size = cannoli->lift_memop(
             0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
             sizeof(shellcode));
 
-        // Make sure the SO library author is not being naughty ;)
+        /* Make sure the SO library author is not being naughty ;) */
         if(shellcode_size > sizeof(shellcode)) {
-            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            fprintf(stderr, "Cannoli: Load shellcode too large\n");
             exit(EXIT_FAILURE);
         }
 
-        // Inject the shellcode into the JIT stream
+        /* Inject the shellcode into the JIT stream */
         for(size_t ii = 0; ii < shellcode_size; ii++) {
             tcg_out8(s, shellcode[ii]);
         }
     }
-#endif // CANNOLI
-#endif
+#endif /* CANNOLI */
 }
 
 static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
@@ -2352,41 +2400,60 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
     oi = *args++;
     opc = get_memop(oi);
 
-#if defined(CONFIG_SOFTMMU)
-    mem_index = get_mmuidx(oi);
-
-    tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,
-                     label_ptr, offsetof(CPUTLBEntry, addr_write));
-
-    /* TLB Hit.  */
-    tcg_out_qemu_st_direct(s, datalo, datahi, TCG_REG_L1, -1, 0, 0, opc);
-
-    /* Record the current context of a store into ldst label */
-    add_qemu_ldst_label(s, false, is64, oi, datalo, datahi, addrlo, addrhi,
-                        s->code_ptr, label_ptr);
-#else
 #ifdef CANNOLI
+    /*
+     * The Cannoli store hook! This is where we log that a write to memory
+     * is about to happen. Unlike load, this is executed _prior_ to the store,
+     * we already know both the data and address information and thus we don't
+     * need to perform the operation to get either of them.
+     *
+     * Just call into Rust and ask for some shellcode!
+     */
     if(cannoli && cannoli->lift_memop) {
-        // Should be large enough for any reasonable shellcode
+        /* Should be large enough for any reasonable shellcode */
         uint8_t shellcode[1024];
 
-        // Invoke lifting callback
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         */
+        if((TCG_TARGET_REG_BITS == 32 && is64) ||
+                (TARGET_LONG_BITS > TCG_TARGET_REG_BITS)) {
+            fprintf(stderr,
+                "Cannoli: 64-bit store on 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        /* Invoke lifting callback */
         size_t shellcode_size = cannoli->lift_memop(
             1, datalo, addrlo, opc & MO_SIZE, shellcode, sizeof(shellcode));
 
-        // Make sure the SO library author is not being naughty ;)
+        /* Make sure the SO library author is not being naughty ;) */
         if(shellcode_size > sizeof(shellcode)) {
-            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            fprintf(stderr, "Cannoli: Store shellcode too large\n");
             exit(EXIT_FAILURE);
         }
 
-        // Inject the shellcode into the JIT stream
+        /* Inject the shellcode into the JIT stream */
         for(size_t ii = 0; ii < shellcode_size; ii++) {
             tcg_out8(s, shellcode[ii]);
         }
     }
-#endif // CANNOLI
+#endif /* CANNOLI */
+
+#if defined(CONFIG_SOFTMMU)
+    mem_index = get_mmuidx(oi);
 
+    tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,
+                     label_ptr, offsetof(CPUTLBEntry, addr_write));
+
+    /* TLB Hit.  */
+    tcg_out_qemu_st_direct(s, datalo, datahi, TCG_REG_L1, -1, 0, 0, opc);
+
+    /* Record the current context of a store into ldst label */
+    add_qemu_ldst_label(s, false, is64, oi, datalo, datahi, addrlo, addrhi,
+                        s->code_ptr, label_ptr);
+#else
     a_bits = get_alignment_bits(opc);
     if (a_bits) {
         tcg_out_test_alignment(s, false, addrlo, addrhi, a_bits);
@@ -4073,16 +4140,32 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     }
 
 #ifdef CANNOLI
+    /*
+     * So, the location that we're hooking here in QEMU is the code which
+     * is emit as the entry and exit routines for the JIT. We're in the
+     * function that is creating the "trampoline" that jumps into the JIT!
+     * We're hooking first thing after registers are saved and we've
+     * "switched" into the JIT context.
+     *
+     * The reason we hook this location is because it provides us with a
+     * low-frequency event that allows us to flush logs. By low frequency,
+     * I really just mean, happens rare enough that I can call into Rust
+     * and do a slightly more complicated operation. This in reality will
+     * be hit likely thousands of times a second, but that's not too hard
+     * for us.
+     */
     if(cannoli && cannoli->jit_entry) {
-        // Save all of the registers which are caller-saved. In theory we could
-        // be a bit more specific here, but this allows us to not interfere
-        // with any shenanigans that QEMU might do now, or in the future. This
-        // gives us our own environment to run in where we don't have to worry
-        // about specifics
-        //
-        // x86-64 SYS-V ABI:
-        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
-        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        /*
+         * Save all of the registers which are caller-saved. In theory we could
+         * be a bit more specific here, but this allows us to not interfere
+         * with any shenanigans that QEMU might do now, or in the future. This
+         * gives us our own environment to run in where we don't have to worry
+         * about specifics
+         *
+         * x86-64 SYS-V ABI:
+         * Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+         * Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+         */
         tcg_out_push(s, TCG_REG_RAX);
         tcg_out_push(s, TCG_REG_RDI);
         tcg_out_push(s, TCG_REG_RSI);
@@ -4093,23 +4176,30 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_push(s, TCG_REG_R10);
         tcg_out_push(s, TCG_REG_R11);
 
-        // Make some room on the stack for the 3 64-bit return values, but also
-        // align the stack to a 16-byte boundary so it matches the x64 ABI
+        /*
+         * Make some room on the stack for the 3 64-bit return values, but also
+         * align the stack to a 16-byte boundary so it matches the x64 ABI
+         */
         tcg_out_addi(s, TCG_REG_RSP, -32);
 
-        // Load a pointer to the temporary storage for the (u64, u64) into the
-        // first argument to `jit_entry`
+        /*
+         * Load a pointer to the temporary storage for the (u64, u64) into the
+         * first argument to `jit_entry`
+         */
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_RSP);
 
+        /* Invoke the JIT entry callback */
         tcg_out_call(s, (void*)cannoli->jit_entry);
 
-        // Load the temporary values returned from `jit_entry`. These are the
-        // values for our registers we have full control over in the JIT
+        /*
+         * Load the temporary values returned from `jit_entry`. These are the
+         * values for our registers we have full control over in the JIT
+         */
         tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_REG_RSP, 0x00);
         tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_REG_RSP, 0x08);
         tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_REG_RSP, 0x10);
 
-        // Restore the stack
+        /* Restore the stack */
         tcg_out_addi(s, TCG_REG_RSP, 32);
         tcg_out_pop(s, TCG_REG_R11);
         tcg_out_pop(s, TCG_REG_R10);
@@ -4121,7 +4211,7 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_pop(s, TCG_REG_RDI);
         tcg_out_pop(s, TCG_REG_RAX);
     }
-#endif
+#endif /* CANNOLI */
 
 #if TCG_TARGET_REG_BITS == 32
     tcg_out_ld(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP,
@@ -4170,16 +4260,23 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     }
 
 #ifdef CANNOLI
+    /*
+     * Here's the JIT exit hook. This calls into our Rust hooks, and will
+     * always be invoked after a JIT entry (unless there's a crash). This is
+     * where we get Rust execution and send off the trace for processing.
+     */
     if(cannoli && cannoli->jit_exit) {
-        // Save all of the registers which are caller-saved. In theory we could
-        // be a bit more specific here, but this allows us to not interfere
-        // with any shenanigans that QEMU might do now, or in the future. This
-        // gives us our own environment to run in where we don't have to worry
-        // about specifics
-        //
-        // x86-64 SYS-V ABI:
-        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
-        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        /*
+         * Save all of the registers which are caller-saved. In theory we could
+         * be a bit more specific here, but this allows us to not interfere
+         * with any shenanigans that QEMU might do now, or in the future. This
+         * gives us our own environment to run in where we don't have to worry
+         * about specifics
+         *
+         * x86-64 SYS-V ABI:
+         * Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+         * Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+         */
         tcg_out_push(s, TCG_REG_RAX);
         tcg_out_push(s, TCG_REG_RDI);
         tcg_out_push(s, TCG_REG_RSI);
@@ -4190,15 +4287,18 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_push(s, TCG_REG_R10);
         tcg_out_push(s, TCG_REG_R11);
 
-        // Load the 3 controlled registers into the first 3 arguments of the
-        // JIT exit function
+        /*
+         * Load the 3 controlled registers into the first 3 arguments of the
+         * JIT exit function
+         */
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_R12);
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RSI, TCG_REG_R13);
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDX, TCG_REG_R14);
 
+        /* Invoke the callback! */
         tcg_out_call(s, (void*)cannoli->jit_exit);
 
-        // Restore the stack
+        /* Restore the stack */
         tcg_out_pop(s, TCG_REG_R11);
         tcg_out_pop(s, TCG_REG_R10);
         tcg_out_pop(s, TCG_REG_R9);
@@ -4209,7 +4309,7 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_pop(s, TCG_REG_RDI);
         tcg_out_pop(s, TCG_REG_RAX);
     }
-#endif
+#endif /* CANNOLI */
 
     for (i = ARRAY_SIZE(tcg_target_callee_save_regs) - 1; i >= 0; i--) {
         tcg_out_pop(s, tcg_target_callee_save_regs[i]);
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 739a4641c3..dde9cd89b3 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4352,35 +4352,36 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
             }
 
 #ifdef CANNOLI
-            // First `insn_start` variable is the PC of the instruction.
-            // It may be encoded as 2 32-bit ints when emulating a
-            // larger-than-native architecture than the host of QEMU.
-            //
-            // We let the code above us handle that decoding, thus we just
-            // access the `gen_insn_data` ourselves
-            if(cannoli) {
-                if(cannoli->lift_instruction) {
-                    // Should be large enough for any reasonable shellcode
-                    uint8_t shellcode[1024];
-
-                    // Get the PC
-                    target_ulong pc = s->gen_insn_data[num_insns][0];
-
-                    // Invoke lifting callback
-                    size_t shellcode_size =
-                        cannoli->lift_instruction(
-                            pc, shellcode, sizeof(shellcode));
-
-                    // Make sure the SO library author is not being naughty ;)
-                    if(shellcode_size > sizeof(shellcode)) {
-                        fprintf(stderr, "Cannoli: Shellcode too large\n");
-                        exit(EXIT_FAILURE);
-                    }
+            /*
+             * First `insn_start` variable is the PC of the instruction.
+             * It may be encoded as 2 32-bit ints when emulating a
+             * larger-than-native architecture than the host of QEMU.
+             *
+             * We let the code above us handle that decoding, thus we just
+             * access the `gen_insn_data` ourselves
+             */
+            if(cannoli && cannoli->lift_instruction) {
+                /* Should be large enough for any reasonable shellcode */
+                uint8_t shellcode[1024];
+
+                /* Get the PC */
+                target_ulong pc = s->gen_insn_data[num_insns][0];
+
+                /* Invoke lifting callback */
+                size_t shellcode_size =
+                    cannoli->lift_instruction(
+                        pc, shellcode, sizeof(shellcode));
+
+                /* Make sure the SO library author is not being naughty ;) */
+                if(shellcode_size > sizeof(shellcode)) {
+                    fprintf(stderr,
+                            "Cannoli: Instruction shellcode too large\n");
+                    exit(EXIT_FAILURE);
+                }
 
-                    // Inject the shellcode into the JIT stream
-                    for(size_t ii = 0; ii < shellcode_size; ii++) {
-                        tcg_out8(s, shellcode[ii]);
-                    }
+                /* Inject the shellcode into the JIT stream */
+                for(size_t ii = 0; ii < shellcode_size; ii++) {
+                    tcg_out8(s, shellcode[ii]);
                 }
             }
 #endif
-- 
2.35.1


From 0efc4ab316ebffdd7a67fe833afcc4458693e760 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Sat, 14 May 2022 00:27:52 -0700
Subject: [PATCH 3/8] Added PC support to memops

---
 tcg/i386/tcg-target.c.inc | 47 +++++++++++++++++++++++++++++++++++++--
 tcg/tcg.c                 | 12 ++++++++++
 2 files changed, 57 insertions(+), 2 deletions(-)

diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index 99168526d6..ae8f662c7f 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -2213,7 +2213,13 @@ static void tcg_out_qemu_ld_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
 /* XXX: qemu_ld and qemu_st could be modified to clobber only EDX and
    EAX. It will be useful once fixed registers globals are less
    common. */
+#ifdef CANNOLI
+/* Add a PC argument so we know what instruction counter is doing the access */
+static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64,
+    target_ulong pc)
+#else
 static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
+#endif /* CANNOLI */
 {
     TCGReg datalo, datahi, addrlo;
     TCGReg addrhi __attribute__((unused));
@@ -2311,7 +2317,7 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
          * we saved it there above.
          */
         size_t shellcode_size = cannoli->lift_memop(
-            0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
+            pc, 0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
             sizeof(shellcode));
 
         /* Make sure the SO library author is not being naughty ;) */
@@ -2380,7 +2386,13 @@ static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
     }
 }
 
+#ifdef CANNOLI
+/* Add a PC argument so we know what instruction counter is doing the access */
+static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64,
+    target_ulong pc)
+#else
 static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
+#endif
 {
     TCGReg datalo, datahi, addrlo;
     TCGReg addrhi __attribute__((unused));
@@ -2425,7 +2437,7 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
         }
 
         /* Invoke lifting callback */
-        size_t shellcode_size = cannoli->lift_memop(
+        size_t shellcode_size = cannoli->lift_memop(pc,
             1, datalo, addrlo, opc & MO_SIZE, shellcode, sizeof(shellcode));
 
         /* Make sure the SO library author is not being naughty ;) */
@@ -2487,7 +2499,21 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
     a2 = args[2];
     const_a2 = const_args[2];
 
+#ifdef CANNOLI
+    // Current program counter. Updated by insn_start instructions
+    target_ulong pc = 0;
+#endif // CANNOLI
+
     switch (opc) {
+#ifdef CANNOLI
+    case INDEX_op_insn_start:
+        // Cannoli enables pushing of `insn_start`s down to this level, so we
+        // actually have to handle it!
+       
+        // Update the current PC tracker
+        pc = *(target_ulong*)const_args;
+        break;
+#endif // CANNOLI
     case INDEX_op_exit_tb:
         /* Reuse the zeroing that exists for goto_ptr.  */
         if (a0 == 0) {
@@ -2755,6 +2781,22 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
         tcg_out_ext16u(s, a0, a1);
         break;
 
+#ifdef CANNOLI
+    /* Cannoli adds a PC argument to loads and stores */
+    case INDEX_op_qemu_ld_i32:
+        tcg_out_qemu_ld(s, args, 0, pc);
+        break;
+    case INDEX_op_qemu_ld_i64:
+        tcg_out_qemu_ld(s, args, 1, pc);
+        break;
+    case INDEX_op_qemu_st_i32:
+    case INDEX_op_qemu_st8_i32:
+        tcg_out_qemu_st(s, args, 0, pc);
+        break;
+    case INDEX_op_qemu_st_i64:
+        tcg_out_qemu_st(s, args, 1, pc);
+        break;
+#else
     case INDEX_op_qemu_ld_i32:
         tcg_out_qemu_ld(s, args, 0);
         break;
@@ -2768,6 +2810,7 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
     case INDEX_op_qemu_st_i64:
         tcg_out_qemu_st(s, args, 1);
         break;
+#endif /* CANNOLI */
 
     OP_32_64(mulu2):
         tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_MUL, args[3]);
diff --git a/tcg/tcg.c b/tcg/tcg.c
index dde9cd89b3..590d997d65 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4384,6 +4384,18 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
                     tcg_out8(s, shellcode[ii]);
                 }
             }
+            
+            // In Cannoli, we actually emit the `insn_start` opcode. Normally
+            // QEMU does not do this, however we want to get access to PC
+            // values deeper in the stack, so we push the value further.
+            TCGArg args[TCG_MAX_OP_ARGS] = { 0 };
+            int consts[TCG_MAX_OP_ARGS] = { 0 };
+
+            // Write in the PC into the `consts` array
+            *(target_ulong*)consts = s->gen_insn_data[num_insns][0];
+
+            // Emit the opcode
+            tcg_out_op(s, op->opc, args, consts);
 #endif
             break;
         case INDEX_op_discard:
-- 
2.35.1


From b3267a15063ece5a3b4f0b950ab4e32b1fba7513 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Sat, 14 May 2022 17:25:18 -0700
Subject: [PATCH 4/8] Updated path

---
 include/tcg/tcg.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 20dc3c68a1..a71cd470f8 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -43,7 +43,7 @@
 #ifdef CONFIG_LINUX_USER
 #define CANNOLI
 #ifdef CANNOLI
-#include "/home/pleb/cannoli/qemu_library/ffi/cannoli.h"
+#include "/home/pleb/cannoli/cannoli_server/ffi/cannoli.h"
 
 /*
  * Defined in `linux-user/main.c`. Holds global cannoli state and callback
-- 
2.35.1


From a48c630bdc849511c49866056fbea2aec6e3d061 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Thu, 19 May 2022 04:37:37 -0700
Subject: [PATCH 5/8] Added --with-cannoli build flag

---
 configure         | 9 +++++++++
 include/tcg/tcg.h | 4 +++-
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/configure b/configure
index 103a7b02e8..024a5e39d0 100755
--- a/configure
+++ b/configure
@@ -299,6 +299,7 @@ plugins="$default_feature"
 meson=""
 meson_args=""
 ninja=""
+cannoli=""
 bindir="bin"
 skip_meson=no
 
@@ -858,6 +859,8 @@ for opt do
   ;;
   --with-coroutine=*) coroutine="$optarg"
   ;;
+  --with-cannoli=*) cannoli="$optarg"
+  ;;
   --disable-zlib-test)
   ;;
   --disable-virtio-blk-data-plane|--enable-virtio-blk-data-plane)
@@ -1044,6 +1047,7 @@ Advanced options (experts only):
   --disable-werror         disable compilation abort on warning
   --disable-stack-protector disable compiler-provided stack protection
   --cpu=CPU                Build for host CPU [$cpu]
+  --with-cannoli=/path/to/cannoli Build with fast Cannoli tracing support
   --with-coroutine=BACKEND coroutine backend. Supported options:
                            ucontext, sigaltstack, windows
   --enable-plugins
@@ -2001,6 +2005,11 @@ if [ "$bsd" = "yes" ] ; then
   echo "CONFIG_BSD=y" >> $config_host_mak
 fi
 
+if [ -n "$cannoli" ] ; then
+    echo "CONFIG_CANNOLI=y" >> $config_host_mak
+    QEMU_CFLAGS="-I$cannoli $QEMU_CFLAGS"
+fi
+
 echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
 
 if test "$have_asan_iface_fiber" = "yes" ; then
diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index a71cd470f8..657dfefc92 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -41,9 +41,10 @@
  * context switches, page table changes, etc.
  */
 #ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
 #define CANNOLI
 #ifdef CANNOLI
-#include "/home/pleb/cannoli/cannoli_server/ffi/cannoli.h"
+#include "cannoli_server/ffi/cannoli.h"
 
 /*
  * Defined in `linux-user/main.c`. Holds global cannoli state and callback
@@ -51,6 +52,7 @@
  */
 extern Cannoli *cannoli;
 #endif /* CANNOLI */
+#endif /* CONFIG_CANNOLI */
 #endif /* CONFIG_LINUX_USER */
 
 /* XXX: make safe guess about sizes */
-- 
2.35.1


From 022d77fc60a9596c05c2cea6ed8a252b772b125a Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Sun, 29 May 2022 20:56:50 -0700
Subject: [PATCH 6/8] Fixed cannoli PC for memory operations

---
 tcg/i386/tcg-target.c.inc | 21 ++++++-----------
 tcg/tcg.c                 | 47 +++++++++++++++++++++++++--------------
 2 files changed, 37 insertions(+), 31 deletions(-)

diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index ae8f662c7f..874e43be29 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -2476,9 +2476,16 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
 #endif
 }
 
+#ifdef CANNOLI
+static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
+                              const TCGArg args[TCG_MAX_OP_ARGS],
+                              const int const_args[TCG_MAX_OP_ARGS],
+                              const target_ulong pc)
+#else
 static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
                               const TCGArg args[TCG_MAX_OP_ARGS],
                               const int const_args[TCG_MAX_OP_ARGS])
+#endif
 {
     TCGArg a0, a1, a2;
     int c, const_a2, vexop, rexw = 0;
@@ -2499,21 +2506,7 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
     a2 = args[2];
     const_a2 = const_args[2];
 
-#ifdef CANNOLI
-    // Current program counter. Updated by insn_start instructions
-    target_ulong pc = 0;
-#endif // CANNOLI
-
     switch (opc) {
-#ifdef CANNOLI
-    case INDEX_op_insn_start:
-        // Cannoli enables pushing of `insn_start`s down to this level, so we
-        // actually have to handle it!
-       
-        // Update the current PC tracker
-        pc = *(target_ulong*)const_args;
-        break;
-#endif // CANNOLI
     case INDEX_op_exit_tb:
         /* Reuse the zeroing that exists for goto_ptr.  */
         if (a0 == 0) {
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 590d997d65..d9d035576a 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -107,9 +107,16 @@ static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
 static bool tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg);
 static void tcg_out_movi(TCGContext *s, TCGType type,
                          TCGReg ret, tcg_target_long arg);
+#ifdef CANNOLI
+static void tcg_out_op(TCGContext *s, TCGOpcode opc,
+                       const TCGArg args[TCG_MAX_OP_ARGS],
+                       const int const_args[TCG_MAX_OP_ARGS],
+                       const target_ulong pc);
+#else
 static void tcg_out_op(TCGContext *s, TCGOpcode opc,
                        const TCGArg args[TCG_MAX_OP_ARGS],
                        const int const_args[TCG_MAX_OP_ARGS]);
+#endif
 #if TCG_TARGET_MAYBE_vec
 static bool tcg_out_dup_vec(TCGContext *s, TCGType type, unsigned vece,
                             TCGReg dst, TCGReg src);
@@ -3650,7 +3657,15 @@ static void tcg_reg_alloc_dup(TCGContext *s, const TCGOp *op)
     }
 }
 
+/* Cannoli passes the PC of the opcode to the IL op */
+#ifdef CANNOLI
+static void tcg_reg_alloc_op(
+        TCGContext *s,
+        const TCGOp *op,
+        const target_ulong pc)
+#else
 static void tcg_reg_alloc_op(TCGContext *s, const TCGOp *op)
+#endif
 {
     const TCGLifeData arg_life = op->life;
     const TCGOpDef * const def = &tcg_op_defs[op->opc];
@@ -3817,7 +3832,12 @@ static void tcg_reg_alloc_op(TCGContext *s, const TCGOp *op)
         tcg_out_vec_op(s, op->opc, TCGOP_VECL(op), TCGOP_VECE(op),
                        new_args, const_args);
     } else {
+#ifdef CANNOLI
+        /* Cannoli passes the PC */
+        tcg_out_op(s, op->opc, new_args, const_args, pc);
+#else
         tcg_out_op(s, op->opc, new_args, const_args);
+#endif
     }
 
     /* move the outputs in the correct register if needed */
@@ -4316,6 +4336,11 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
     s->pool_labels = NULL;
 #endif
 
+#ifdef CANNOLI
+    // Current target program counter. Updated by insn_start instructions
+    target_ulong cannoli_pc = (target_ulong)0xdeaddeaddeaddeadULL;
+#endif // CANNOLI
+
     num_insns = -1;
     QTAILQ_FOREACH(op, &s->ops, link) {
         TCGOpcode opc = op->opc;
@@ -4352,6 +4377,9 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
             }
 
 #ifdef CANNOLI
+            /* Record the PC of the target instruction */
+            cannoli_pc = s->gen_insn_data[num_insns][0];
+
             /*
              * First `insn_start` variable is the PC of the instruction.
              * It may be encoded as 2 32-bit ints when emulating a
@@ -4364,13 +4392,10 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
                 /* Should be large enough for any reasonable shellcode */
                 uint8_t shellcode[1024];
 
-                /* Get the PC */
-                target_ulong pc = s->gen_insn_data[num_insns][0];
-
                 /* Invoke lifting callback */
                 size_t shellcode_size =
                     cannoli->lift_instruction(
-                        pc, shellcode, sizeof(shellcode));
+                        cannoli_pc, shellcode, sizeof(shellcode));
 
                 /* Make sure the SO library author is not being naughty ;) */
                 if(shellcode_size > sizeof(shellcode)) {
@@ -4384,18 +4409,6 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
                     tcg_out8(s, shellcode[ii]);
                 }
             }
-            
-            // In Cannoli, we actually emit the `insn_start` opcode. Normally
-            // QEMU does not do this, however we want to get access to PC
-            // values deeper in the stack, so we push the value further.
-            TCGArg args[TCG_MAX_OP_ARGS] = { 0 };
-            int consts[TCG_MAX_OP_ARGS] = { 0 };
-
-            // Write in the PC into the `consts` array
-            *(target_ulong*)consts = s->gen_insn_data[num_insns][0];
-
-            // Emit the opcode
-            tcg_out_op(s, op->opc, args, consts);
 #endif
             break;
         case INDEX_op_discard:
@@ -4419,7 +4432,7 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
             /* Note: in order to speed up the code, it would be much
                faster to have specialized register allocator functions for
                some common argument patterns */
-            tcg_reg_alloc_op(s, op);
+            tcg_reg_alloc_op(s, op, cannoli_pc);
             break;
         }
 #ifdef CONFIG_DEBUG_TCG
-- 
2.35.1


From 314324d41e3082f9352993b9d1183f8c16c2c72c Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Mon, 30 May 2022 00:30:14 -0700
Subject: [PATCH 7/8] Wrap code in cannoli as needed

---
 tcg/tcg.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/tcg/tcg.c b/tcg/tcg.c
index d9d035576a..8c508de957 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4432,7 +4432,11 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
             /* Note: in order to speed up the code, it would be much
                faster to have specialized register allocator functions for
                some common argument patterns */
+#ifdef CANNOLI
             tcg_reg_alloc_op(s, op, cannoli_pc);
+#else
+            tcg_reg_alloc_op(s, op);
+#endif
             break;
         }
 #ifdef CONFIG_DEBUG_TCG
-- 
2.35.1


From ad9c7ffa61da0d4a25f045acd126731228341bf4 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Mon, 30 May 2022 06:05:07 -0700
Subject: [PATCH 8/8] Fixed cannoli not flushing on longjmps and signals

---
 accel/tcg/cpu-exec-common.c | 16 ++++++++++++++++
 accel/tcg/cpu-exec.c        |  5 +++++
 linux-user/signal.c         | 26 ++++++++++++++++++++++++++
 target/alpha/cpu.h          |  7 +++++++
 target/arm/cpu.h            |  7 +++++++
 target/avr/cpu.h            |  7 +++++++
 target/cris/cpu.h           |  7 +++++++
 target/hexagon/cpu.h        |  7 +++++++
 target/hppa/cpu.h           |  7 +++++++
 target/i386/cpu.h           |  7 +++++++
 target/m68k/cpu.h           |  7 +++++++
 target/microblaze/cpu.h     |  7 +++++++
 target/mips/cpu.h           |  7 +++++++
 target/nios2/cpu.h          |  7 +++++++
 target/openrisc/cpu.h       |  7 +++++++
 target/ppc/cpu.h            |  7 +++++++
 target/riscv/cpu.h          |  7 +++++++
 target/rx/cpu.h             |  7 +++++++
 target/s390x/cpu.h          |  6 ++++++
 target/sh4/cpu.h            |  7 +++++++
 target/sparc/cpu.h          |  7 +++++++
 target/tricore/cpu.h        |  7 +++++++
 target/xtensa/cpu.h         |  7 +++++++
 tcg/tcg.c                   | 26 ++++++++++++++++++++++++++
 24 files changed, 212 insertions(+)

diff --git a/accel/tcg/cpu-exec-common.c b/accel/tcg/cpu-exec-common.c
index be6fe45aa5..e74228fb5b 100644
--- a/accel/tcg/cpu-exec-common.c
+++ b/accel/tcg/cpu-exec-common.c
@@ -22,6 +22,12 @@
 #include "sysemu/tcg.h"
 #include "exec/exec-all.h"
 
+#ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
+#include "tcg/tcg.h"
+#endif /* CONFIG_CANNOLI */
+#endif /* CONFIG_LINUX_USER */
+
 bool tcg_allowed;
 
 /* exit the current TB, but without causing any exception to be raised */
@@ -63,6 +69,16 @@ void cpu_reloading_memory_map(void)
 
 void cpu_loop_exit(CPUState *cpu)
 {
+#ifdef CANNOLI
+    /* If we ever exit the CPU loop, perform a JIT exit */
+    if(cannoli && cannoli->jit_exit) {
+        CPUArchState *env = cpu->env_ptr;
+
+        cannoli->jit_exit(
+                env->cannoli_r12, env->cannoli_r13, env->cannoli_r14);
+    }
+#endif
+
     /* Undo the setting in cpu_tb_exec.  */
     cpu->can_do_io = 1;
     siglongjmp(cpu->jmp_env, 1);
diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index 635aeecc0a..affc38ce5b 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -352,6 +352,11 @@ cpu_tb_exec(CPUState *cpu, TranslationBlock *itb, int *tb_exit)
     TranslationBlock *last_tb;
     const void *tb_ptr = itb->tc.ptr;
 
+#ifdef CANNOLI
+    /* Poison the cannoli state before entering the JIT */
+    env->cannoli_r12 = CANNOLI_POISON;
+#endif
+
     log_cpu_exec(itb->pc, cpu, itb);
 
     qemu_thread_jit_execute();
diff --git a/linux-user/signal.c b/linux-user/signal.c
index 8d29bfaa6b..09ad99e384 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -33,6 +33,12 @@
 #include "host-signal.h"
 #include "user/safe-syscall.h"
 
+#ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
+#include "tcg/tcg.h"
+#endif /* CONFIG_CANNOLI */
+#endif /* CONFIG_LINUX_USER */
+
 static struct target_sigaction sigact_table[TARGET_NSIG];
 
 static void host_signal_handler(int host_signum, siginfo_t *info,
@@ -823,6 +829,13 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
     bool sync_sig = false;
     void *sigmask = host_signal_mask(uc);
 
+#ifdef CANNOLI
+    /* Save the register state in the cannoli C state */
+    env->cannoli_r12 = uc->uc_mcontext.gregs[REG_R12];
+    env->cannoli_r13 = uc->uc_mcontext.gregs[REG_R13];
+    env->cannoli_r14 = uc->uc_mcontext.gregs[REG_R14];
+#endif
+
     /*
      * Non-spoofed SIGSEGV and SIGBUS are synchronous, and need special
      * handling wrt signal blocking and unwinding.
@@ -852,6 +865,10 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
                 /* If this was a write to a TB protected page, restart. */
                 if (is_write &&
                     handle_sigsegv_accerr_write(cpu, sigmask, pc, guest_addr)) {
+#ifdef CANNOLI
+                    /* Re-poison cannoli */
+                    env->cannoli_r12 = CANNOLI_POISON;
+#endif
                     return;
                 }
 
@@ -881,6 +898,10 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
     /* get target signal number */
     guest_sig = host_to_target_signal(host_sig);
     if (guest_sig < 1 || guest_sig > TARGET_NSIG) {
+#ifdef CANNOLI
+        /* Re-poison cannoli */
+        env->cannoli_r12 = CANNOLI_POISON;
+#endif
         return;
     }
     trace_user_host_signal(env, host_sig, guest_sig);
@@ -922,6 +943,11 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
 
     /* interrupt the virtual CPU as soon as possible */
     cpu_exit(thread_cpu);
+
+#ifdef CANNOLI
+    /* Re-poison cannoli */
+    env->cannoli_r12 = CANNOLI_POISON;
+#endif
 }
 
 /* do_sigaltstack() returns target values and errnos. */
diff --git a/target/alpha/cpu.h b/target/alpha/cpu.h
index d0abc949a8..f54fb0f15f 100644
--- a/target/alpha/cpu.h
+++ b/target/alpha/cpu.h
@@ -250,6 +250,13 @@ typedef struct CPUArchState {
     uint32_t features;
     uint32_t amask;
     int implver;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUAlphaState;
 
 /**
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index 18ca61e8e2..a919ffdc48 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -746,6 +746,13 @@ typedef struct CPUArchState {
     /* Linux syscall tagged address support */
     bool tagged_addr_enable;
 #endif
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUARMState;
 
 static inline void set_feature(CPUARMState *env, int feature)
diff --git a/target/avr/cpu.h b/target/avr/cpu.h
index d304f33301..53a0034682 100644
--- a/target/avr/cpu.h
+++ b/target/avr/cpu.h
@@ -135,6 +135,13 @@ typedef struct CPUArchState {
     bool fullacc; /* CPU/MEM if true MEM only otherwise */
 
     uint64_t features;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUAVRState;
 
 /**
diff --git a/target/cris/cpu.h b/target/cris/cpu.h
index e6776f25b1..d3dbd56701 100644
--- a/target/cris/cpu.h
+++ b/target/cris/cpu.h
@@ -165,6 +165,13 @@ typedef struct CPUArchState {
 
         /* Members from load_info on are preserved across resets.  */
         void *load_info;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUCRISState;
 
 /**
diff --git a/target/hexagon/cpu.h b/target/hexagon/cpu.h
index 2a65a57bab..b20f9ebcc6 100644
--- a/target/hexagon/cpu.h
+++ b/target/hexagon/cpu.h
@@ -128,6 +128,13 @@ typedef struct CPUArchState {
     target_ulong vstore_pending[VSTORES_MAX];
     bool vtcm_pending;
     VTCMStoreLog vtcm_log;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUHexagonState;
 
 OBJECT_DECLARE_CPU_TYPE(HexagonCPU, HexagonCPUClass, HEXAGON_CPU)
diff --git a/target/hppa/cpu.h b/target/hppa/cpu.h
index 6f3b6beecf..3d8a6e599c 100644
--- a/target/hppa/cpu.h
+++ b/target/hppa/cpu.h
@@ -206,6 +206,13 @@ typedef struct CPUArchState {
     /* ??? We should use a more intelligent data structure.  */
     hppa_tlb_entry tlb[HPPA_TLB_ENTRIES];
     uint32_t tlb_last;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUHPPAState;
 
 /**
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 0d528ac58f..a2ce2aaebf 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -1771,6 +1771,13 @@ typedef struct CPUArchState {
     TPRAccess tpr_access_type;
 
     unsigned nr_dies;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUX86State;
 
 struct kvm_msrs;
diff --git a/target/m68k/cpu.h b/target/m68k/cpu.h
index 9b3bf7a448..855acdb2af 100644
--- a/target/m68k/cpu.h
+++ b/target/m68k/cpu.h
@@ -149,6 +149,13 @@ typedef struct CPUArchState {
 
     /* Fields from here on are preserved across CPU reset. */
     uint32_t features;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUM68KState;
 
 /*
diff --git a/target/microblaze/cpu.h b/target/microblaze/cpu.h
index 1e84dd8f47..ea21031cb2 100644
--- a/target/microblaze/cpu.h
+++ b/target/microblaze/cpu.h
@@ -291,6 +291,13 @@ struct CPUArchState {
     struct {} end_reset_fields;
 
     /* These fields are preserved on reset.  */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 /*
diff --git a/target/mips/cpu.h b/target/mips/cpu.h
index 5335ac10a3..433112d479 100644
--- a/target/mips/cpu.h
+++ b/target/mips/cpu.h
@@ -1160,6 +1160,13 @@ typedef struct CPUArchState {
     QEMUTimer *timer; /* Internal timer */
     target_ulong exception_base; /* ExceptionBase input to the core */
     uint64_t cp0_count_ns; /* CP0_Count clock period (in nanoseconds) */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUMIPSState;
 
 /**
diff --git a/target/nios2/cpu.h b/target/nios2/cpu.h
index f85581ee56..a60954cc16 100644
--- a/target/nios2/cpu.h
+++ b/target/nios2/cpu.h
@@ -200,6 +200,13 @@ struct CPUArchState {
     Nios2MMU mmu;
 #endif
     int error_code;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 typedef struct {
diff --git a/target/openrisc/cpu.h b/target/openrisc/cpu.h
index b9584f10d4..355084f27f 100644
--- a/target/openrisc/cpu.h
+++ b/target/openrisc/cpu.h
@@ -290,6 +290,13 @@ typedef struct CPUArchState {
     uint32_t picmr;         /* Interrupt mask register */
     uint32_t picsr;         /* Interrupt contrl register*/
 #endif
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUOpenRISCState;
 
 /**
diff --git a/target/ppc/cpu.h b/target/ppc/cpu.h
index 48596cfb25..73b752b732 100644
--- a/target/ppc/cpu.h
+++ b/target/ppc/cpu.h
@@ -1233,6 +1233,13 @@ struct CPUArchState {
      * running cycles.
      */
     uint64_t pmu_base_time;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 #define SET_FIT_PERIOD(a_, b_, c_, d_)          \
diff --git a/target/riscv/cpu.h b/target/riscv/cpu.h
index fe6c9a2c92..bed470c3aa 100644
--- a/target/riscv/cpu.h
+++ b/target/riscv/cpu.h
@@ -341,6 +341,13 @@ struct CPUArchState {
     uint64_t kvm_timer_compare;
     uint64_t kvm_timer_state;
     uint64_t kvm_timer_frequency;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 OBJECT_DECLARE_CPU_TYPE(RISCVCPU, RISCVCPUClass, RISCV_CPU)
diff --git a/target/rx/cpu.h b/target/rx/cpu.h
index 5655dffeff..372bf94bc5 100644
--- a/target/rx/cpu.h
+++ b/target/rx/cpu.h
@@ -98,6 +98,13 @@ typedef struct CPUArchState {
     uint32_t ack_ipl;           /* execute ipl */
     float_status fp_status;
     qemu_irq ack;               /* Interrupt acknowledge */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPURXState;
 
 /*
diff --git a/target/s390x/cpu.h b/target/s390x/cpu.h
index 7d6d01325b..512c69bd03 100644
--- a/target/s390x/cpu.h
+++ b/target/s390x/cpu.h
@@ -151,6 +151,12 @@ struct CPUArchState {
     /* currently processed sigp order */
     uint8_t sigp_order;
 
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 static inline uint64_t *get_freg(CPUS390XState *cs, int nr)
diff --git a/target/sh4/cpu.h b/target/sh4/cpu.h
index 9f15ef913c..17a6d7fd01 100644
--- a/target/sh4/cpu.h
+++ b/target/sh4/cpu.h
@@ -188,6 +188,13 @@ typedef struct CPUArchState {
     int in_sleep;		/* SR_BL ignored during sleep */
     memory_content *movcal_backup;
     memory_content **movcal_backup_tail;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUSH4State;
 
 /**
diff --git a/target/sparc/cpu.h b/target/sparc/cpu.h
index f80ea2e8cf..380c740282 100644
--- a/target/sparc/cpu.h
+++ b/target/sparc/cpu.h
@@ -549,6 +549,13 @@ struct CPUArchState {
 
     /* Leon3 cache control */
     uint32_t cache_control;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 /**
diff --git a/target/tricore/cpu.h b/target/tricore/cpu.h
index 3b9c533a7c..28035d9763 100644
--- a/target/tricore/cpu.h
+++ b/target/tricore/cpu.h
@@ -189,6 +189,13 @@ typedef struct CPUArchState {
     const tricore_def_t *cpu_model;
     void *irq[8];
     struct QEMUTimer *timer; /* Internal timer */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUTriCoreState;
 
 /**
diff --git a/target/xtensa/cpu.h b/target/xtensa/cpu.h
index 579adcb769..da4af8d732 100644
--- a/target/xtensa/cpu.h
+++ b/target/xtensa/cpu.h
@@ -547,6 +547,13 @@ struct CPUArchState {
 
     /* Watchpoints for DBREAK registers */
     struct CPUWatchpoint *cpu_watchpoint[MAX_NDBREAK];
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 /**
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 8c508de957..6d2de178e9 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4063,6 +4063,20 @@ static void tcg_reg_alloc_call(TCGContext *s, TCGOp *op)
         save_globals(s, allocated_regs);
     }
 
+#ifdef CANNOLI
+    /* Save current cannoli registers to an accessible-by-C location as we may
+     * be calling something that longjmp()s from inside QEMU's JIT to outside
+     * and will need to flush the buffers. Thus, from C functions we have to
+     * have access to the current buffer state.
+     */
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r12));
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r13));
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r14));
+#endif
+
 #ifdef CONFIG_TCG_INTERPRETER
     {
         gpointer hash = (gpointer)(uintptr_t)info->typemask;
@@ -4074,6 +4088,18 @@ static void tcg_reg_alloc_call(TCGContext *s, TCGOp *op)
     tcg_out_call(s, func_addr);
 #endif
 
+#ifdef CANNOLI
+    /* Poison the current C-side cannoli register state as we're about to
+     * track them in registers.
+     *
+     * We re-poison here as we're about to go back into the JIT as the call
+     * above returned back to us instead of longjmp()ing.
+     */
+    tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_RDI, CANNOLI_POISON);
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r12));
+#endif
+
     /* assign output registers and emit moves if needed */
     for(i = 0; i < nb_oargs; i++) {
         arg = op->args[i];
-- 
2.35.1

